<p>
Opcode: <input id=m0 size=2 value=00> <input id=m1 size=2 value=00> <input id=m2 size=2 value=00>
<p>
A: <input id=rA value=00 size=2> X: <input id=rX value=00 size=2> Y: <input id=rY value=00 size=2> PC: <input id=rPC value=8000 size=4> S: <input id=rS value=200 size=4> P: <input id=rP value=34 size=2>
<p>
<button id=run>run</button>

<script>

// Mini 6502 simulator
// ===================

// Globals
// -------

// 16kb memory
m = [];

// Registers
A = X = Y = 0;
S = 512;
PC = 0x8000;
P = 0x34;

// Helpers
// -------

// Read a byte from memory. Costs 1 cycle.
r = v => {
  c++;
  return m[v];
},

// Write a byte in memory. Costs 1 cycle.
w = (v, w) => {
  c++;
  m[v] = w;
},

// Update Z
z = v => {
  P |= 2 * ((v & 255) > 0);
},

// Update N, Z
y = v => {
  z(v);
  P |= (128 & v);
},

// Update N, Z, C
x = v => {
  y(v);
  P |= (v > 255);
  return v & 255;
},

// Push on Stack (wraps between $100 and $1FF)
e = v => {
  w(S--, n),
  S = 256 + (255 & S)
},

// Pull from stack
f = v => {
  return r(S = 256 + (255 & S++))
},

// Emulation
// =========

// Execute the next opcode, at the address pointed by the PC register
i = v => {
  
  // Reset the cycle counter
  c = 0;
  
  // Save opcode address in O
  O = PC;
  
  // Fetch opcode (costs 1 cycle), save it in o, increment PC
  o = r(PC++);
  
  // Fetch opcode operand at address PC = O + 1 (costs 1 cycle), save it in p
  p = m[PC];
  
  // Temp var
  t = 0;
  
  // Interrupts (ignored here) set B to 0 and execut a routine before resuming the opcode's execution
  // B = 1;
  
  // Addressing modes (different ways to indicate an address in memory)
  // The resulting address is saved in a
  // If the opcode has no operand, PC is not incremented 
  a = eval(
    [
      // Immediate: address = O + 1. Increment PC 
      "(PC++)",

      // Zero page: address (between $00 and $FF) is stored at O + 1. Increment PC
      "(PC++,p)",

      // Relative: address (between PC - 128 and PC + 127) = PC + signed offset stored at address O + 1. Increment PC
      "(PC++,PC+p-256*(p>127))",

      // Absolute: address is stored at O + 1 (low byte) and O + 2 (high byte). Increment PC twice
      "(PC++,p+256*r(PC++))",

      // Zero page X: address is equal to zero page (at O + 1) + X, wrapping between $00 and $FF. Increment PC
      "(PC++,p+X&255)",

      // Zero page Y: address is equal to zero page (at O + 1) + Y, wrapping between $00 and $FF. Increment PC
      "(PC++,p+Y&255)",

      // Absolute X: address is equal to absolute (at O + 1 and O + 2) + X. Cross-page costs 1 cycle. Increment PC twice
      "(PC++,t=p+256*r(PC++),c+=t>>8!=t+X>>8,t+X)",

      // Absolute Y: address is equal to absolute (at O + 1 and O + 2) + Y. Cross-page costs 1 cycle. Increment PC twice
      "(PC++,t=p+256*r(PC++),c+=t>>8!=t+Y>>8,t+Y)",

      // Indexed indirect X: absolute address is stored at zero page address stored at O + 1 + X. Zero page wrap costs 1 cycle. Increment PC
      "(PC++,c+=p>>8!=p+X>>8,r(p+X&255)+256*r(p+X+1&255))",

      // Indirect indexed Y: absolute address is stored at zero page address stored at O + 1, and Y is added to it. Zero page wrap costs 1 cycle. Increment PC
      "(PC++,t=r(p)+256*r(p+1),c+=t>>8!=t+Y>>8,t+Y)",
    ]
    [
      "08ZZ11Z00Z3329ZZ44Z7ZZ6608Z111Z0033329ZZ44Z7ZZ66Z8ZZ11Z0003329ZZ44Z7ZZ66Z8ZZ11Z00Z3329ZZ44Z7ZZ66Z8Z111ZZZ33329Z445Z7ZZ6Z080111Z0Z33329Z445Z7Z66708Z411Z0Z33329ZZ44Z7ZZ6608Z111Z0Z33329ZZ44Z7ZZ66"[o-~~(o/4)]
    ]
  );

  // Instructions:
  // 0 ADC // 1 AND // 2 ASL // 3 BCC // 4 BCS // 5 BEQ // 6 BIT // 7 BMI
  // 8 BNE // 9 BPL // a BRK // b BVC // c BVS // d CLC // e CLD // f CLI
  // g CLV // h CMP // i CPX // j CPY // k DEC // l DEX // m DEY // n EOR
  // o INC // p INX // q INY // r JMP // s JSR // t LDA // u LDX // v LDY
  // w LSR // x NOP // y ORA // z PHA // A PHP // B PLA // C PLP // D ROL
  // E ROR // F RTI // G RTS // H SBC // I SEC // J SED // K SEI // L STA
  // M STX // N STY // O TAX // P TAY // Q TSX // R TXA // S TXS // T TYA // Z invaid
  
  // Byte at address a is stored in p (costs 1 cycle)
  p = r(a);
  
  // Instruction
  eval(
    {
      // ADC (add with carry): A = A + p + C. Flags: N, Z, C, V. cycles: 2/3/4/4/4*/4*/6/5*
      0: "t=A+p+(1&P),P|=(128&!(A^p)&&(A,t))*64,A=x(t)",
      
      // AND: (and operator): A = A AND p. Flags: N, Z. cycles: 2/3/4/4/4*/4*/6/5*
      1: "A=y(A&p)",
      
      // ASL (shift left): A or byte in memory <<= 1. Flags: N, Z, C. cycles: 2/5/6/6/7
      2: "10==(15&o)?A=x(2*A):w(a,x(2*r(a))",
      
      // BCC (branch on carry clear): PC = address if C is 0. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      3: "(1&P)||(PC=a,c+=1+(0<a>>8))",
      
      // BCS (branch on carry set): PC = address if C is 1. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      4: "(1&P)&&(PC=a,c+=1+(0<a>>8))",
      
      // BEQ (branch if equal): PC = address if Z is 0. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      5: "(2&P)&&(PC=a,c+=1+(0<a>>8))",
      
      // BIT (test bits in memory): N, V = bit 7 and 6 of operand. Z = operand & A. Flags: N, Z, V. cycles: 3/4.
      6: "P|=192&p,z(p&A)",
      
      // BMI (branch on minus): PC = address if N is 1. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      7: "(128&P)&&(PC=a,c+=1+(0<a>>8))",
      
      // BNE (branch if not equal): PC = address if Z is 0. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      8: "(2&P)||(PC=a,c+=1+(0<a>>8))",
      
      // BPL (branch on plus): PC = address if N is 0. cycles: 2/3/4 (Same-page branch costs 1 cycle. Cross-page branch costs 2 cycles)
      9: "(128&P)||(PC=a,c+=1+(0<a>>8))",
      
      // BRK: 
      a: "PC+=2,e(PC>>8),e(255&PC),e(P),P|=4,PC=r(65534)+256*r(65535)",
      
      // BVC: 
      b: "(64&P)||(PC=a,c+=1+(0<a>>8))",
      
      // BVS:
      c: "(64&P)&&(PC=a,c+=1+(0<a>>8))",
      
      // CLC:
      d: "P&=254",
      
      // CLD:
      e: "P&=247",
      
      // CLI:
      f: "P&=251",
      
      // CLV:
      g: "P&=191",
      
      // CMP:
      h: "x(A-p)",
      
      // CPX
      i: "x(X-p)",
      
      // CPY
      j: "x(Y-p)",
      
      // DEC
      k: "w(a,y(m[a]-1))",
      
      // DEX
      l: "y(--X)",
      
      // DEY
      m: "y(--Y)",
      
      // EOR
      n: "A=y(p^A)",
      
      // INC
      o: "w(a,y(r(a)+1))",
      
      // INX
      p: "y(++X)",
      
      // INY
      q: "y(++Y)",
      
      // JMP
      r: "o>>8==6&&(PC++,a=r(PC++)+(r(PC)<<8)),PC=a",
      
      // JSR
      s: "e(PC>>8),e(PC&255),PC=a",
      
      // LDA
      t: "A=y(p)",
      
      // LDX
      u: "X=y(p)",
      
      // LDY
      v: "Y=y(p)",
      
      // LSR
      w: "10==(15&o)?A=x(A>>1):w(a,x(r(a)>>1))",
      
      // NOP
      //x: "",
      
      // ORA
      y: "A=y(p|A)",
      
      // PHA
      z: "e(A)",
      
      // PHP
      A: "e(P)",
      
      // PLA
      B: "A=y(f())",
      
      // PLP
      C: "P=f()",
      
      // ROL
      D: "10==(15&o)?A=x(2*A+(1&P)):w(a,x(2*r(a)+(1&P)))",
      
      // ROR
      E: "10==(15&o)?A=x(A>>1+128*(1&P)):w(a,x(r(a)>>1+128*(1&P)))",
      
      // RTI
      F: "P=f(),PC=f()+256*f()",
      
      // RTS
      G: "PC=f()+256*f()",
      
      // SBC
      H: "t=A-p-(1-(P&1)),P|=64*(128&(A^p)&&128&(A^t)),A=x(t)",
      
      // SEC
      I: "P|=1",
      
      // SED
      J: "P|=8",
      
      // SEI
      K: "P|=4",
      
      // STA
      L: "w(a,A)",
      
      // STX
      M: "w(a,X)",
      
      // STY
      N: "w(a,Y)",
      
      // TAX
      O: "X=y(A)",
      
      // TAY
      P: "Y=y(A)",
      
      // TSX
      Q: "X=y(S-256)",
      
      // TXA
      R: "A=y(X)",
      
      // TXS
      S: "S=X+256",
      
      // TYA
      T: "A=y(Y)",
    }
    [
      "ayZZy2Ay2Zy29yZZy2dyZZy2s1Z61DC1D61D71ZZ1DI1ZZ1DFnZZnwznwrnwbnZZnwfnZZnwG0ZZ0EB0Er0Ec0ZZ0EK0ZZ0EZLZNLMmZRNLM3LZNLMTLSZLZvtuvtuPtOvtu4tZvtugtQvtujhZjhkqhljhk8hZZhkehZZhkiHZiHopHxiHo5HZZHoJHZZHo"[o-~~(o/4)]
    ]
  );
}

// Demo

T = () => { console.log("Tick"); }

run.onclick = () => {
  m[PC] = parseInt(op.value, 16) || 0;
  m[PC+1] = parseInt(o1.value, 16) || 0;
  m[PC+1] = parseInt(o2.value, 16) || 0;
  console.log(m[PC]);
  op();
  console.log({A,X,Y,S,P,PC})
}
</script>