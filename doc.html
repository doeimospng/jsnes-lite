> Opcodes $00-$FF

     +----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
     | 00       | 01        | 02        | 03        | 04        | 05        | 06        | 07        | 08        | 09        | 0A        | 0B        | 0C        | 0D        | 0E        | 0F        |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+
| 00 | BRK      | ORA (d,x) | STP       | SLO (d,x) | NOP d     | ORA d     | ASL d     | SLO d     | PHP       | ORA #i    | ASL       | ANC #i    | NOP a     | ORA a     | ASL a     | SLO a     |
| 10 | BPL *+d  | ORA (d),y | STP       | SLO (d),y | NOP d,x   | ORA d,x   | ASL d,x   | SLO d,x   | CLC       | ORA a,y   | NOP       | SLO a,y   | NOP a,x   | ORA a,x   | ASL a,x   | SLO a,x   |
| 20 | JSR a    | AND (d,x) | STP       | RLA (d,x) | BIT d     | AND d     | ROL d     | RLA d     | PLP       | AND #i    | ROL       | ANC #i    | BIT a     | AND a     | ROL a     | RLA a     |
| 30 | BMI *+d  | AND (d),y | STP       | RLA (d),y | NOP d,x   | AND d,x   | ROL d,x   | RLA d,x   | SEC       | AND a,y   | NOP       | RLA a,y   | NOP a,x   | AND a,x   | ROL a,x   | RLA a,x   |
| 40 | RTI      | EOR (d,x) | STP       | SRE (d,x) | NOP d     | EOR d     | LSR d     | SRE d     | PHA       | EOR #i    | LSR       | ALR #i    | JMP a     | EOR a     | LSR a     | SRE a     |
| 50 | BVC *+d  | EOR (d),y | STP       | SRE (d),y | NOP d,x   | EOR d,x   | LSR d,x   | SRE d,x   | CLI       | EOR a,y   | NOP       | SRE a,y   | NOP a,x   | EOR a,x   | LSR a,x   | SRE a,x   |
| 60 | RTS      | ADC (d,x) | STP       | RRA (d,x) | NOP d     | ADC d     | ROR d     | RRA d     | PLA       | ADC #i    | ROR       | ARR #i    | JMP (a)   | ADC a     | ROR a     | RRA a     |
| 70 | BVS *+d  | ADC (d),y | STP       | RRA (d),y | NOP d,x   | ADC d,x   | ROR d,x   | RRA d,x   | SEI       | ADC a,y   | NOP       | RRA a,y   | NOP a,x   | ADC a,x   | ROR a,x   | RRA a,x   |
| 80 | NOP #i   | STA (d,x) | NOP #i    | SAX (d,x) | STY d     | STA d     | STX d     | SAX d     | DEY       | NOP #i    | TXA       | XAA #i    | STY a     | STA a     | STX a     | SAX a     |
| 90 | BCC *+d  | STA (d),y | STP       | AHX (d),y | STY d,x   | STA d,x   | STX d,y   | SAX d,y   | TYA       | STA a,y   | TXS       | TAS a,y   | SHY a,x   | STA a,x   | SHX a,y   | AHX a,y   |
| A0 | LDY #i   | LDA (d,x) | LDX #i    | LAX (d,x) | LDY d     | LDA d     | LDX d     | LAX d     | TAY       | LDA #i    | TAX       | LAX #i    | LDY a     | LDA a     | LDX a     | LAX a     |
| B0 | BCS *+d  | LDA (d),y | STP       | LAX (d),y | LDY d,x   | LDA d,x   | LDX d,y   | LAX d,y   | CLV       | LDA a,y   | TSX       | LAS a,y   | LDY a,x   | LDA a,x   | LDX a,y   | LAX a,y   |
| C0 | CPY #i   | CMP (d,x) | NOP #i    | DCP (d,x) | CPY d     | CMP d     | DEC d     | DCP d     | INY       | CMP #i    | DEX       | AXS #i    | CPY a     | CMP a     | DEC a     | DCP a     |
| D0 | BNE *+d  | CMP (d),y | STP       | DCP (d),y | NOP d,x   | CMP d,x   | DEC d,x   | DCP d,x   | CLD       | CMP a,y   | NOP       | DCP a,y   | NOP a,x   | CMP a,x   | DEC a,x   | DCP a,x   |
| E0 | CPX #i   | SBC (d,x) | NOP #i    | ISC (d,x) | CPX d     | SBC d     | INC d     | ISC d     | INX       | SBC #i    | NOP       | SBC #i    | CPX a     | SBC a     | INC a     | ISC a     |
| F0 | BEQ *+d  | SBC (d),y | STP       | ISC (d),y | NOP d,x   | SBC d,x   | INC d,x   | ISC d,x   | SED       | SBC a,y   | NOP       | ISC a,y   | NOP a,x   | SBC a,x   | INC a,x   | ISC a,x   |
+----+----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+-----------+

> Opcodes detail:

+-----+----------+----------------------------------------------------------------------------+---------------------------------------------------------------------------------------------------------------------------------------------+
|     | Affected |                 Cycles spent for each addressing mode                      |                                                                                                                                             |
| Op. | flags    |    | A  | #i | d  | d,X | d,Y | a  | a,X | a,Y | *+d | (a) | (d,X) | (d),Y | Details ("M" represents a byte in CPU memory)                                                                                               |
+-----+----------+----+----+----+----+-----+-----+----+-----+-----+-----+-----+-------+-------+---------------------------------------------------------------------------------------------------------------------------------------------+
| ADC | CZ---VN  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | A = A + M + C. C = 1 if bit 7 of A overflows, 0 otherwise. Z = 1 if A = 0, 0 otherwise. N = bit 7 of A.                                     |
| AND | -Z----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | A = M AND A. Z = 1 if A = 0, 0 otherwise. N: bit 7 of result.                                                                               |
| ASL | CZ----N  |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | C = bit 7 of operand. Operand = operand << 1. Bit 0 of result = 0. Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                    |
| BCC | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if C = 0.                                                                                                                        |
| BCS | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if C = 1.                                                                                                                        |
| BEQ | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if Z = 1.                                                                                                                        |
| BIT | --Z--VN  |    |    |    | 3  |     |     | 4  |     |     |     |     |       |       | AND the bitmask stored in A and M. Z = 1 if result = 0, 0 otherwise. V = M6. N = bit 7 of M                                                 |
| BMI | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if N = 1.                                                                                                                        |
| BNE | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if Z = 0.                                                                                                                        |
| BPL | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if N = 0.                                                                                                                        |
| BRK | ----B--  | 7  |    |    |    |     |     |    |     |     |     |     |       |       | Generate an IRQ request.                                                                                                                    |
| BVC | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if O = 0.                                                                                                                        |
| BVS | -------  |    |    |    |    |     |     |    |     |     | 2*  |     |       |       | PC += rel, if O = 1.                                                                                                                        |
| CLC | C------  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Clear carry flag.                                                                                                                           |
| CLD | ---D---  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Clear decimal flag.                                                                                                                         |
| CLI | --I----  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Clear interrupt disable flag.                                                                                                               |
| CLV | -----V-  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Clear overflow tag.                                                                                                                         |
| CMP | CZ----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | Compare A and M. C = 1 if A >= M, 0 otherwise. Z = 1 if A = M, 0 otherwise. N: bit 7 of A - M.                                              |
| CPX | CZ----N  |    |    | 2  | 3  |     |     | 4  |     |     |     |     |       |       | Compare X and M. C = 1 if X >= M, 0 otherwise. Z = 1 if X = M, 0 otherwise. N: bit 7 of X - M.                                              |
| CPY | CZ----N  |    |    | 2  | 3  |     |     | 4  |     |     |     |     |       |       | Compare Y and M. C = 1 if Y >= M, 0 otherwise. Z = 1 if Y = M, 0 otherwise. N: bit 7 of Y - M.                                              |
| DEC | -Z----N  |    |    |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | Decrement M (if 0: set it to 255). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| DEX | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Decrement X (if 0: set it to 255). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| DEY | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Decrement Y (if 0: set it to 255). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| EOR | -Z----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | Store M XOR A into A. Z = 1 if A = 0, 0 otherwise. N: bit 7 of result.                                                                      |
| INC | -Z----N  |    |    |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | Increment M (if 255: set it to 0). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| INX | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Increment X (if 255: set it to 0). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| INY | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Increment Y (if 255: set it to 0). Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                                                    |
| JMP | -------  |    |    |    |    |     |     | 3  |     |     |     | 5   |       |       | Jump (set PC) to the address in the operand. (*).                                                                                           |
| JSR | -------  |    |    |    |    |     |     | 6  |     |     |     |     |       |       | Jump to subroutine: push (address of next operation - 1) on the stack (highest byte then lowest byte) and set PC to the address in operand. |
| LDA | -Z----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | Load M in A. Z = 1 if A = 0, 0 otherwise. N: bit 7 of A.                                                                                    |
| LDX | -Z----N  |    |    | 2  | 3  |     | 4   | 4  |     | 4+  |     |     |       |       | Load M in X. Z = 1 if X = 0, 0 otherwise. N: bit 7 of X.                                                                                    |
| LDY | -Z----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  |     |     |     |       |       | Load M in Y. Z = 1 if Y = 0, 0 otherwise. N: bit 7 of Y.                                                                                    |
| LSR | CZ----N  |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | Right shift operand after putting bit 0 in C. Bit 7 = 0. Z = 1 if result = 0, 0 otherwise. N: bit 7 of result.                              |
| NOP | -------  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | No operation.                                                                                                                               |
| ORA | -Z----N  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | Store M OR A into A. Z = 1 if A = 0, 0 otherwise. N = 1 if bit 7 is set.                                                                    |
| PHA | -------  | 3  |    |    |    |     |     |    |     |     |     |     |       |       | Push A on the stack.                                                                                                                        |
| PHP | -------  | 3  |    |    |    |     |     |    |     |     |     |     |       |       | Push P (the status flags) on the stack.                                                                                                     |
| PLA | -Z----N  | 4  |    |    |    |     |     |    |     |     |     |     |       |       | Pull A from the stack. Z = 1 if A = 0, 0 otherwise. N: bit 7 of A.                                                                          |
| PLP | CZIDBVN  | 4  |    |    |    |     |     |    |     |     |     |     |       |       | Pull P from the stack, and update all the flags with the values pulled.                                                                     |
| ROL | CZ----N  |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | Save C in a var. Put bit 7 of operand in C. Left shift operand. Bit 0 = saved C. Z = 1 if operand is 0, 1 otherwise. N: bit 7 of operand.   |
| ROR | CZ----N  |    | 2  |    | 5  | 6   |     | 6  | 7   |     |     |     |       |       | Save C in a var. Put bit 0 of operand in C. Right shift operand. Bit 7 = saved C. Z = 1 if operand is 0, 1 otherwise. N: bit 7 of operand.  |
| RTI | CZIDBVN  | 6  |    |    |    |     |     |    |     |     |     |     |       |       | Return from interrupt: pull P (the flags) and PC from the stack.                                                                            |
| RTS | -------  | 6  |    |    |    |     |     |    |     |     |     |     |       |       | Return from subroutine: pull PC from the stack (the lowest byte, then the highest byte, see JSR), increment it, and jump to it.             |
| SBC | CZ---VN  |    |    | 2  | 3  | 4   |     | 4  | 4+  | 4+  |     |     | 6     | 5+    | Store A - M - NOT C into A. C: 0 if bit 7 overflows, else 1. Z: 1 if A = 0, else 0. V: 1 if sign bit is wrong, else 0. N: bit 7 of result.  |
| SEC | C------  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Set carry flag.                                                                                                                             |
| SED | ---D---  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Set decimal flag.                                                                                                                           |
| SEI | --I----  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Set interrupt disable flag.                                                                                                                 |
| STA | -------  |    |    |    | 3  | 4   |     | 4  | 5   | 5   |     |     | 6     | 6     | Store A in M.                                                                                                                               |
| STX | -------  |    |    |    | 3  |     | 4   | 4  |     |     |     |     |       |       | Store X in M.                                                                                                                               |
| STY | -------  |    |    |    | 3  | 4   |     | 4  |     |     |     |     |       |       | Store Y in M.                                                                                                                               |
| TAX | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy A in X. Z = 1 if X = 0, 0 otherwise. N: bit 7 of X.                                                                                    |
| TAY | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy A in Y. Z = 1 if Y = 0, 0 otherwise. N: bit 7 of Y.                                                                                    |
| TSX | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy S in X. Z = 1 if X = 0, 0 otherwise. N: bit 7 of X.                                                                                    |
| TXA | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy X in A. Z = 1 if A = 0, 0 otherwise. N: bit 7 of A.                                                                                    |
| TXS | -------  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy X in S.                                                                                                                                | 
| TYA | -Z----N  | 2  |    |    |    |     |     |    |     |     |     |     |       |       | Copy Y in A. Z = 1 if A = 0, 0 otherwise. N: bit 7 of A.                                                                                    |
+-----+----------+----+----+----+----+-----+-----+----+-----+-----+-----+-----+-------+-------+---------------------------------------------------------------------------------------------------------------------------------------------+

"+" means that 1 extra cycle is used during write or during a read on a different page (called cross-page read).
"*" means that 1 extra cycle is used if the branch succeeds and 1 other extra cycle is used if the branch goes to a new page.

---

> Addressing modes:

+-------+-------------------+-------+----------------------------------------------------------+----------------+
| Abbr. | Name              | Bytes | Address of the opcode's operand                          | Opcode cycles  |
+-------+-------------------+-------+----------------------------------------------------------+----------------+
|       | Implicit          | 0     | No operand or implied operand (ex: RTS, CLC)             | 2-7            |
| A     | Accumulator       | 0     | Implied operand is A (ex: LSR == LSR A)                  | 2              |
| #i    | Immediate         | 1     | PC + 1                                                   | 2              |
| d     | Zero page         | 1     | d = memory[PC + 1]                                       | 3-5            |
| *+d   | relative          | 1     | PC + 2 + signed(memory[PC + 1])                          | 2-4            |
| a     | Absolute          | 2     | a = (memory[PC + 2] << 8) + memory[PC + 1]               | 3-6            |
| (a)   | Indirect          | 2     | (memory[a + 1] << 8) + memory[a]                         | 5              | \
| d,X   | Zero page indexed | 1     | (memory[PC + 1] + X) % 256                               | 4-6            | |
| d,Y   | Zero page indexed | 1     | (memory[PC + 1] + Y) % 256                               | 4              | |
| a,X   | Absolute indexed  | 2     | a + X                                                    | 4-7            | |_ indexed
| a,Y   | Absolute indexed  | 2     | a + Y                                                    | 4-5            | |  operand
| (d,X) | Indexed indirect  | 1     | (memory[(d + X + 1) % 256] << 8) + memory[(d + X) % 256] | 6              | |
| (d),Y | Indirect indexed  | 1     | (memory[(d + 1) % 256] << 8) + memory[d] + Y             | 5-6            | |
+-------+-------------------+------------------------------------------------------------------+----------------+ /
